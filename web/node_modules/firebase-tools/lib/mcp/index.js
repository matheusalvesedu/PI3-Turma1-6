"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FirebaseMcpServer = void 0;
const index_js_1 = require("@modelcontextprotocol/sdk/server/index.js");
const stdio_js_1 = require("@modelcontextprotocol/sdk/server/stdio.js");
const types_js_1 = require("@modelcontextprotocol/sdk/types.js");
const util_js_1 = require("./util.js");
const index_js_2 = require("./tools/index.js");
const configstore_js_1 = require("../configstore.js");
const index_js_3 = require("./tools/core/index.js");
const command_js_1 = require("../command.js");
const requireAuth_js_1 = require("../requireAuth.js");
const projectUtils_js_1 = require("../projectUtils.js");
const errors_js_1 = require("./errors.js");
const SERVER_VERSION = "0.0.1";
const PROJECT_ROOT_KEY = "mcp.projectRoot";
const cmd = new command_js_1.Command("experimental:mcp").before(requireAuth_js_1.requireAuth);
class FirebaseMcpServer {
    constructor(options) {
        var _a, _b, _c;
        this.activeFeatures = options.activeFeatures;
        this.server = new index_js_1.Server({ name: "firebase", version: SERVER_VERSION });
        this.server.registerCapabilities({ tools: { listChanged: true } });
        this.server.setRequestHandler(types_js_1.ListToolsRequestSchema, this.mcpListTools.bind(this));
        this.server.setRequestHandler(types_js_1.CallToolRequestSchema, this.mcpCallTool.bind(this));
        this.projectRoot =
            (_c = (_b = (_a = options.projectRoot) !== null && _a !== void 0 ? _a : configstore_js_1.configstore.get(PROJECT_ROOT_KEY)) !== null && _b !== void 0 ? _b : process.env.PROJECT_ROOT) !== null && _c !== void 0 ? _c : process.cwd();
        if (options.projectRoot)
            this.fixedRoot = true;
    }
    get availableTools() {
        var _a;
        const toolDefs = this.fixedRoot ? [] : [...index_js_3.coreTools];
        const activeFeatures = ((_a = this.activeFeatures) === null || _a === void 0 ? void 0 : _a.length)
            ? this.activeFeatures
            : Object.keys(index_js_2.tools);
        for (const key of activeFeatures || []) {
            toolDefs.push(...index_js_2.tools[key]);
        }
        return toolDefs;
    }
    getTool(name) {
        return this.availableTools.find((t) => t.mcp.name === name) || null;
    }
    async mcpListTools() {
        const hasActiveProject = !!(await this.getProjectId());
        return {
            tools: this.availableTools.map((t) => t.mcp),
            _meta: {
                projectRoot: this.projectRoot,
                projectDetected: hasActiveProject,
                authenticated: await this.getAuthenticated(),
                activeFeatures: this.activeFeatures,
            },
        };
    }
    setProjectRoot(newRoot) {
        if (newRoot === null) {
            configstore_js_1.configstore.delete(PROJECT_ROOT_KEY);
            this.projectRoot = process.env.PROJECT_ROOT || process.cwd();
            void this.server.sendToolListChanged();
            return;
        }
        configstore_js_1.configstore.set(PROJECT_ROOT_KEY, newRoot);
        this.projectRoot = newRoot;
        void this.server.sendToolListChanged();
    }
    async resolveOptions() {
        const options = { cwd: this.projectRoot };
        await cmd.prepare(options);
        return options;
    }
    async getProjectId() {
        return (0, projectUtils_js_1.getProjectId)(await this.resolveOptions());
    }
    async getAuthenticated() {
        try {
            await (0, requireAuth_js_1.requireAuth)(await this.resolveOptions());
            return true;
        }
        catch (e) {
            return false;
        }
    }
    async mcpCallTool(request) {
        var _a, _b;
        const toolName = request.params.name;
        const toolArgs = request.params.arguments;
        const tool = this.getTool(toolName);
        if (!tool)
            throw new Error(`Tool '${toolName}' could not be found.`);
        const projectId = await this.getProjectId();
        if (((_a = tool.mcp._meta) === null || _a === void 0 ? void 0 : _a.requiresAuth) && !(await this.getAuthenticated()))
            return (0, errors_js_1.mcpAuthError)();
        if (((_b = tool.mcp._meta) === null || _b === void 0 ? void 0 : _b.requiresProject) && !projectId)
            return errors_js_1.NO_PROJECT_ERROR;
        try {
            return tool.fn(toolArgs, { projectId: await this.getProjectId(), host: this });
        }
        catch (err) {
            return (0, util_js_1.mcpError)(err);
        }
    }
    async start() {
        const transport = new stdio_js_1.StdioServerTransport();
        await this.server.connect(transport);
    }
}
exports.FirebaseMcpServer = FirebaseMcpServer;
